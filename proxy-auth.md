I, along with many other people, believe that web-based MUD clients are going
to become more and more prevalent. Due to the nature of browsers, these clients
will require MUD codebases that speak WebSockets or serve Flash policy files.
Another solution is proxy servers that DO speak these transports and can then
proxy the connection to the MUD. However, this proxying has its own host of
problems due to IP-based multiplaying restrictions, amongst other things.

This draft attempts to define an easy-to-implement IP-forwarding
protocol between proxies and MUD servers. It includes a mechanism for signing
messages between the two parties, allowing data authenticity and consistency
to be ensured.

The basic idea is a new telnet suboption that sends a specially formatted
[HMAC](http://en.wikipedia.org/wiki/HMAC) (using SHA-1 for the hash function)
along with the client information. The HMAC is generated using a secret key
shared between the proxy and the server. The inspiration for this comes from
Amazon AWS, and more specifically a distilled version of this auth style that
I read at
http://www.thebuzzmedia.com/designing-a-secure-rest-api-without-oauth-authentication/

## Workflow

If messages will be signed, the PROXY and SERVER must communicate beforehand to
exchange a secret key and a unique identifier. This only happens once ever, and
it should be done via a secure medium. Unless the key's authorization is revoked,
it can be used for all future communications.

Following is the basic communication workflow. More details are in the sections
on the ClientInfo and Disconnect commands below.

* CLIENT connects to PROXY, selects the MUD they want to play from a list.
* PROXY looks up the secret key and the public key for that MUD.
* PROXY initiates connection to SERVER.
* During telnet negotation, PROXY informs the server that it IS a proxy by
  sending `IAC WILL PROXY`.
* SERVER responds that it supports the `PROXY` option by sending `IAC DO PROXY`.
* PROXY submits a `ClientInfo` message to the SERVER, optionally including a
  signature.
* If a signature was provided, SERVER optionally generates its own signature
  from the data and compares the two.
* If something went wrong, SERVER may send a `Disconnect` message.

## Telnet Options and General Information

The actual telnet option will be `\xCA` which is decimal `202`. It will use
a command/value syntax with JSON payloads (mostly) similar to GMCP.

## Keys for Identification

The public key will be unique per proxy server, and should be
a [UUID](http://en.wikipedia.org/wiki/Universally_unique_identifier) in hex
format (32 bytes). The secret key may be provided/generated by either party and
currently has no restrictions.

The secret key SHOULD be exchanged in a secure manner, or else a third party
may intercept it. Encrypted web communications (such as an online form via
HTTPS) should be sufficient.

## Signing / Authentication

Every command defined in this document MAY include a signature for the purpose
of confirming data consistency and origin. If present, it MUST be created
through HMAC, using SHA1 as the hash function, represented as a string of
hexadecimal digits. Example Ruby code:

    OpenSSL::HMAC.digest(
      OpenSSL::Digest::Digest.new('sha1'),
      secret_key,
      data
    )

## Message Format

A message compliant with this document will have the following format:

    COMMAND SIGNATURE:DATA

More precisely, a message must conform to the following regular expression:

    ^([^ ]+) (?:([A-Za-z0-9]+):)?(.*)$

The SIGNATURE field, if present, MUST be the result of the aforementioned HMAC
signing process.

The DATA field MUST be a JSON-encoded object of the form:

    {
      "id": <PROXY UUID>,
      "timestamp": <TIMESTAMP>,
      <OTHER FIELDS>
    }

where <PROXY UUID> is the UUID of the proxy, and <TIMESTAMP> is a UNIX timestamp.
Any message MAY also include message-specific fields, or even extraneous fields
not documented for the message. Any message with extraneous fields MUST NOT be
denied; those fields that are not used MUST simply be ignored.

## Commands

Any command listed below MAY be signed unless otherwise noted.

### ClientInfo

This command MUST be sent by the proxy after Telopt negotiation. The following
fields MUST be included:

* proxy_name - (String, OPTIONAL) The descriptive title of the proxy.
* proxy_version - (String, OPTIONAL) The proxy's current version.
* client_addr - (String, REQUIRED) The CLIENT's IP address. This may be an
  IPv4 address in dotted-decimal notation, or an IPv6 address contained within
  brackets [].
  Example: "127.0.0.1" (IPv4) or "[::1]" (IPv6)

Example data:

```javascript
{
    "proxy_name": "RedLantern",
    "proxy_version": "0.1.1",
    "client_addr": "[::ffff:192.0.2.128]",
    "timestamp": 123456789,
    "id": "5e3f7ade701644eb8c8b8e34558d6cc2"
}
```

The server MUST accept the listed keys, and MUST NOT assume that these keys are
the only keys that will be sent. A proxy MAY send an arbitrary number of
additional key/value pairs in this message, and the server MUST accept these
values, even if they do nothing with them.

### Disconnect

The Disconnect command is a way for a MUD server to communicate back to the
proxy that it will not be accepting the connection. The Disconnect command MUST
be sent if the server will not accept a particular connection.

The value of the Disconnect command MUST be a JSON object with at least one
key: `reason`, which maps to one of the reasons listed below. Some of the
reasons listed below will have additional keys that SHOULD be sent, and the
proxy MUST accept Disconnect commands without those additional keys present.

The server MAY optionally supply another key named `message`, containing
a textual description of why the connection will not be allowed. The proxy and
the server both MUST NOT use the message as a way to pass additional metadata.

Possible reasons:

* EXPIRED
    * If the timestamp is too old, the server MAY send back a message like so:
      `IAC SB PROXY Disconnect {"reason": "EXPIRED"} IAC SE`
* UNAUTHORIZED
    * If the public key could not be located or is revoked:
      `IAC SB PROXY Disconnect {"reason": "UNAUTHORIZED"} IAC SE`
* TOOMANY
    * If the server has a connection limit for the proxy, the server MAY send
      this back: `IAC SB PROXY Disconnect {"reason": "TOOMANY"} IAC SE`
    * Additional keys:
        * `max_connections`, the value of which should be an integer
          representing the maximum number of allowed connections from this
          proxy.
        * `current_connections`, the value of which should be an integer
          representing the current number of connections from this proxy.
* BANNED
    * The server can inform the proxy that a certain client address is banned
      using this reason. The server may also send a message informing the
      client why they were banned:
      `IAC SB PROXY Disconnect {"reason": "BANNED",
      "message": "Temporary ban for being an idiot. Come back in
      2 weeks."} IAC SE`
    * Additional keys:
        * `expiration` the value of which should be the number of seconds that
          the ban will last. This may be presented to the user.

The proxy MAY do what it wants with the message. In some cases, it may present
them to the user, in other cases, it may log them internally. The message must
NOT be used to pass additional metadata (such as the proxy using the content of
the message to determine the actual connection limit).

## Additional Information

### Key Leaks

There are two parties that can leak the shared secret keys, the MUD and the
proxy.

If the MUD leaks a shared key, the damage is minimal. The only thing that can
happen is that a malicious user (if they had the public key as well) can
present themselves as the proxy that was previously identified by the leaked
key. It is recommended that MUD servers log the origin of each connection from
a supposed proxy, and raise a red flag if they receive a connection from
a source that they are not expecting.

If the proxy leaks a particular shared key, the problem is the same as the
server leaking it, and the damage can be mitigated in the same way, by the MUD
server logging all connection attempts using a given public key and comparing
the origin of that connection with the expected origin.

If either party discovers a leak, they should immediately notify the other
party and remove the leaked key from their respective configurations, and
generate a new shared key to use.

## FAQ

### Why a new protocol, why not make it a command in an existing protocol?

The primary reason is because existing protocols are intended to be client <-> server.
By rolling this into an existing protocol, the server and proxy must both support
the full spec of the existing protocol, and the proxy must tell the server that
it supports this protocol, which could in turn lead to the server making assumptions
about capabilities.

For example, let's say it was supported as a GMCP package. The server must have
support for the GMCP spec, to start with and so must the proxy. The proxy must then
attempt to negotiate support for GMCP with the server to send the client information.
The proxy then must inspect every incoming message from the server to see if it's
a GMCP message and if it's a GMCP message that it needs to act on. It also needs to
ensure that if the client does (or does not) support GMCP that it properly forwards
or blocks those messages.

### Wouldn't it be simpler to embed the signature into the data object?

The problem with embedding the signature into the data object (ie, as a key in the json
object instead of preceding it) is that both parties need to generate the signature
using the exact same string. If we took this approach, then this is what would need
to happen:

* Sender builds the object containing the properties it needs to send, then serializes
this object according to a very strict set of rules.
* Sender generates the signature using the serialized string.
* Sender inserts the signature into the original object, then reserializes it and creates
the full message.
* Sender sends the full message to the receiver.

* Receiver parses the message and extracts the data.
* Receiver deserializes the data, extracts the public key, timestamp, and signature.
* Receiver looks up the secret key, and reserializes the data object (without the
signature) using the exact same set of strict rules as the sender.
* Receiver generates the signature using the reserialized string.
* Receiver compares the two signatures.

The biggest issue here is that you have to have a very clearly defined set of rules as to
how you are supposed to format the serialized string, since both parties need to use *exactly*
the same string and secret key to generate the same signature.

Instead of relying on these rules that complicate things, we move the signature out of the
serialized string. This allows both parties to use the exact same serialized string without
any additional parsing/restructuring overhead.

### What happens if someone else poses as an existing MUD server, and a proxy with support for that server connects to it?

In this scenario (user A intercepts requests for the hostname/ip that MUD
M uses, which causes connections from proxy P to go to MUD B), the user running
the fake MUD B would receive the connection attempts, but since there is
nothing sensitive that is actually passed over this protocol, there is nothing
that he can do with the information.

One potential problem here is if MUD B exists solely to phish credentials from
users that think they are connecting to MUD M, the plan will succeed just fine.
However, there's nothing we can reasonably do about this, considering this
attack would affect everyone, not just users going through a particular proxy.

## Final Thoughts

The implementation is simple. The code is simple. The timestamp check ensures
that replay attacks (an attacker somehow getting hold of a message and trying
to use it to authenticate itself as the proxy) are extremely difficult (if not
impossible). Because of the shared secret keys, the server can trust what is
coming through, and it means that an attacker cannot spoof themselves as
a trusted proxy to get around IP based multiplaying restrictions without the
secret key.
